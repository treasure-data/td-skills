# =============================================================================
# Step 1: Segments
# =============================================================================
#
# Build ALL segments the journey needs in a single step:
#   - Goal segment
#   - Stage criteria (entry_criteria, exit_criteria, milestone)
#   - Decision point branches
#   - Wait condition triggers
#
# --- REQUIRED: Discovery & Data Analysis First (do NOT skip) ---
# Before writing ANY segment rules, you MUST:
#
# 1. Discover available attributes and behaviors:
#      tdx sg fields
#
# 2. Analyze actual data values to determine rule thresholds:
#      tdx query "SELECT column, COUNT(*) FROM table GROUP BY 1 ORDER BY 2 DESC LIMIT 20"
#
#    Column names alone are NOT enough to write rules.
#    You MUST query actual data to understand:
#      - What values exist (e.g., status column: "active", "churned", "pending"?)
#      - Value distributions (e.g., avg purchase amount, login count ranges)
#      - Behavior table names and their row counts
#
#    Use `tdx ps desc -o` to get the output database/table name for queries.
#
# Do NOT guess attribute names or threshold values.
# Always verify with real data before writing segment rules.
#
# --- Segment Strategy ---
# Ask the client which approach to use:
#
# Option A: Create new embedded segments (recommended)
#   - Use `tdx sg fields` output to build rules
#   - Define segments inline in the segments: section
#
# Option B: Reuse existing segments
#   - Run `tdx sg list` to discover existing child segments
#   - Run `tdx sg sql "Segment Name"` to inspect segment rules
#   - Reference with ref: prefix: segment: ref:Existing Segment
#   - Even with this approach, some segments will likely need to be embedded
#
# --- Segment Rule Reference ---
# Use `tdx sg fields` output to build rules. Common operators:
#
#   Equal             Exact match:     value: "true"
#   In                Multiple values: value: ["a", "b"]
#   GreaterEqual      Numeric:         value: 1000
#   LessEqual         Numeric:         value: 7
#   TimeWithinPast    Recency:         value: 7, unit: day
#   TimeBeforePast    Inactivity:      value: 30, unit: day
#   Contain           String contains: value: "@gmail.com"
#
# Behavior aggregation (requires source: behavior_<table_name>):
#   - type: Value
#     attribute: ""                # Empty for behavior count
#     operator:
#       type: GreaterEqual
#       value: 1
#     aggregation:
#       type: Count                # Count | Sum | Avg | Min | Max
#     source: behavior_purchases   # behavior_<table_name>
#
# --- Organization ---
# Group segments by purpose with comments:
#   # -- Goal --
#   # -- Stage 1: Name --
#   # entry_criteria / milestone / exit_criteria / decision_point / wait_condition
#
# --- Wait Condition Segments ---
# Wait steps come in two types. Ask the client which they need:
#
#   1. Duration wait (no segment needed):
#      Wait a fixed number of days/weeks before continuing.
#      Example: "Wait 3 days after sending email"
#
#   2. Condition wait (segment needed):
#      Wait until the user matches a segment, with optional timeout.
#      Example: "Wait until user makes a purchase, up to 7 days"
#      The segment defines the condition to watch for.
#
# For each stage, ask: "Do any wait steps need to watch for a user action
# (condition), or are they all fixed time delays (duration)?"
#
# --- After updating the YAML ---
#   1. Write ONLY the segments: section (no goal, stages, or steps yet)
#   2. Add "# NEW" comments to highlight additions beyond criteria
#   3. Summarize decision/wait structure at the bottom as comments
#   4. Write the updated YAML to the journey file
#   5. Show the segment design to the client and get confirmation.
#      Once confirmed, write the YAML and immediately move to Step 2.
#      Do NOT ask "shall we proceed?" after writing — confirmation was already given.
#
# =============================================================================

type: journey
name: Welcome Onboarding Journey
description: 3-stage onboarding flow for new customers
reentry: no_reentry

segments:
  # -- Goal --
  onboarding_completed:
    description: User completed product setup
    rule:
      type: And
      conditions:
        - type: Value
          attribute: onboarding_status
          operator:
            type: Equal
            value: "completed"

  # -- Stage 1: Welcome & Engagement --
  # entry_criteria
  new_signups:
    description: Users who signed up in the last 7 days
    rule:
      type: And
      conditions:
        - type: Value
          attribute: signup_date
          operator:
            type: TimeWithinPast
            value: 7
            unit: day
  # milestone
  email_engaged:
    description: Users who opened welcome email
    rule:
      type: And
      conditions:
        - type: Value
          attribute: email_opened
          operator:
            type: Equal
            value: "true"
  # exit_criteria (ref:Churned Users)
  #
  # decision_point: Email Open Check
  # - "Opened" branch (reuses: email_engaged)
  # - "Not Opened" branch (excluded — no segment needed)
  #
  # wait steps: duration only (no segments needed)

  # -- Stage 2: Product Activation --
  # entry_criteria (reuses: email_engaged)
  # exit_criteria (ref:Churned Users)
  #
  # decision_point: Usage Level Check
  power_users:                                                 # NEW
    description: Users with 10+ logins and 5+ features used
    rule:
      type: And
      conditions:
        - type: Value
          attribute: login_count_7d
          operator:
            type: GreaterEqual
            value: 10
        - type: Value
          attribute: feature_usage_count
          operator:
            type: GreaterEqual
            value: 5
  # - "Active" branch (reuses: active_users)
  # - "Inactive" branch (excluded — no segment needed)
  #
  # wait steps: duration only (no segments needed)

  # -- Stage 3: Retention & Loyalty --
  # entry_criteria
  active_users:
    description: Users with 3+ logins in 7 days
    rule:
      type: And
      conditions:
        - type: Value
          attribute: login_count_7d
          operator:
            type: GreaterEqual
            value: 3
  # exit_criteria (ref:Churned Users)
  #
  # decision_point: NPS Score Check
  nps_promoters:                                               # NEW
    description: NPS score 9 or above
    rule:
      type: And
      conditions:
        - type: Value
          attribute: nps_score
          operator:
            type: GreaterEqual
            value: 9
  nps_detractors:                                              # NEW
    description: NPS score 6 or below
    rule:
      type: And
      conditions:
        - type: Value
          attribute: nps_score
          operator:
            type: LessEqual
            value: 6
  # - "Passive" branch (excluded — no segment needed)
  #
  # wait steps: duration only (no segments needed)

  # --- Example: Wait condition segment ---
  # If a stage needs a condition-based wait (e.g., "wait until purchase"):
  #
  # made_purchase:                                             # NEW (wait_condition)
  #   description: User completed a purchase
  #   rule:
  #     type: And
  #     conditions:
  #       - type: Value
  #         attribute: ""
  #         operator:
  #           type: GreaterEqual
  #           value: 1
  #         aggregation:
  #           type: Count
  #         source: behavior_purchases

# Structure summary (for reference when building steps in Step 3):
#
# Stage 1 — Email Open Check (decision_point):
#   - Opened:      segment: email_engaged  → next: (content path)
#   - Not Opened:  excluded: true          → next: (reminder path)
#   Waits: duration only
#
# Stage 2 — Usage Level Check (decision_point):
#   - Power User:  segment: power_users    → next: (upsell path)
#   - Active:      segment: active_users   → next: (tips path)
#   - Inactive:    excluded: true          → next: (reengage path)
#   Waits: duration only
#
# Stage 3 — NPS Score Check (decision_point):
#   - Promoter:    segment: nps_promoters  → next: (referral path)
#   - Detractor:   segment: nps_detractors → next: (support path)
#   - Passive:     excluded: true          → next: (thank you path)
#   Waits: duration only
